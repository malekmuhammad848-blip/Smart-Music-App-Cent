import 'dart:math';
import 'dart:typed_data';
import 'package:flutter/material.dart';
import 'package:fft/fft.dart';

// ============================================================================
// 1. THE SYNC ENGINE: VisualAudioSynchronizer
// ============================================================================

class VisualAudioSynchronizer {
  final ComplexFft _fft = ComplexFft(1024);
  final List<double> _audioBuffer = List.filled(1024, 0.0);
  final List<double> _previousMagnitudes = List.filled(512, 0.0);
  final List<double> _smoothedMagnitudes = List.filled(512, 0.0);
  
  // Particle velocity mapping parameters
  double _bassEnergy = 0.0;
  double _midEnergy = 0.0;
  double _trebleEnergy = 0.0;
  double _overallIntensity = 0.0;
  double _beatProbability = 0.0;
  
  // Time domain tracking
  DateTime _lastBeatTime = DateTime.now();
  final List<double> _energyHistory = List.filled(60, 0.0);
  int _historyIndex = 0;
  
  // Frequency band definitions
  static const _bassRange = Range(20, 250);
  static const _midRange = Range(251, 4000);
  static const _trebleRange = Range(4001, 20000);
  
  void processAudioChunk(Float32List audioSamples) {
    // Update circular buffer
    for (int i = 0; i < audioSamples.length; i++) {
      _audioBuffer[i] = audioSamples[i];
    }
    
    // Perform FFT
    final fftResult = _fft.Transform(_audioBuffer);
    
    // Calculate magnitudes and map to particle parameters
    _calculateFrequencyBands(fftResult);
    _calculateBeatDetection();
    _smoothMagnitudes();
    
    // Update energy history for tempo analysis
    _energyHistory[_historyIndex] = _overallIntensity;
    _historyIndex = (_historyIndex + 1) % _energyHistory.length;
  }
  
  void _calculateFrequencyBands(List<Complex> fftData) {
    double bassSum = 0.0;
    double midSum = 0.0;
    double trebleSum = 0.0;
    
    for (int i = 0; i < 512; i++) {
      final magnitude = sqrt(pow(fftData[i].real, 2) + pow(fftData[i].imag, 2));
      _previousMagnitudes[i] = magnitude;
      
      final frequency = i * (44100 / 1024);
      
      if (frequency >= _bassRange.low && frequency <= _bassRange.high) {
        bassSum += magnitude;
      } else if (frequency >= _midRange.low && frequency <= _midRange.high) {
        midSum += magnitude;
      } else if (frequency >= _trebleRange.low && frequency <= _trebleRange.high) {
        trebleSum += magnitude;
      }
    }
    
    _bassEnergy = _applyLogScale(bassSum / 100);
    _midEnergy = _applyLogScale(midSum / 300);
    _trebleEnergy = _applyLogScale(trebleSum / 100);
    _overallIntensity = (_bassEnergy + _midEnergy + _trebleEnergy) / 3.0;
  }
  
  void _calculateBeatDetection() {
    final currentTime = DateTime.now();
    final timeSinceLastBeat = currentTime.difference(_lastBeatTime).inMilliseconds;
    
    // Calculate average energy variance
    double energySum = 0.0;
    for (final energy in _energyHistory) {
      energySum += energy;
    }
    final averageEnergy = energySum / _energyHistory.length;
    
    // Beat detection algorithm
    final energyVariance = (_overallIntensity - averageEnergy).abs();
    final threshold = 0.3 + (timeSinceLastBeat > 500 ? 0.2 : 0.0);
    
    if (energyVariance > threshold && timeSinceLastBeat > 200) {
      _beatProbability = 1.0;
      _lastBeatTime = currentTime;
    } else {
      _beatProbability = max(0.0, _beatProbability - 0.05);
    }
  }
  
  void _smoothMagnitudes() {
    const smoothingFactor = 0.7;
    for (int i = 0; i < 512; i++) {
      _smoothedMagnitudes[i] = smoothingFactor * _smoothedMagnitudes[i] + 
                               (1 - smoothingFactor) * _previousMagnitudes[i];
    }
  }
  
  double _applyLogScale(double value) {
    return log(1 + value) / log(10);
  }
  
  // Particle velocity mapping
  ParticleVelocityData calculateParticleVelocities(ParticleType type) {
    switch (type) {
      case ParticleType.bass:
        return ParticleVelocityData(
          baseVelocity: _bassEnergy * 15.0,
          turbulence: _beatProbability * 8.0,
          directionalBias: Offset(_midEnergy * 2 - 1, _trebleEnergy * 2 - 1),
          sizeMultiplier: 1.0 + _bassEnergy * 0.5,
        );
      case ParticleType.mid:
        return ParticleVelocityData(
          baseVelocity: _midEnergy * 12.0,
          turbulence: _overallIntensity * 6.0,
          directionalBias: Offset(sin(_midEnergy * pi), cos(_trebleEnergy * pi)),
          sizeMultiplier: 0.8 + _midEnergy * 0.3,
        );
      case ParticleType.treble:
        return ParticleVelocityData(
          baseVelocity: _trebleEnergy * 20.0,
          turbulence: _bassEnergy * 10.0,
          directionalBias: Offset(cos(_bassEnergy * pi), sin(_midEnergy * pi)),
          sizeMultiplier: 0.5 + _trebleEnergy * 0.4,
        );
    }
  }
  
  List<double> getFrequencySpectrum() => _smoothedMagnitudes;
  double getBassEnergy() => _bassEnergy;
  double getMidEnergy() => _midEnergy;
  double getTrebleEnergy() => _trebleEnergy;
  double getBeatProbability() => _beatProbability;
}

class Range {
  final int low;
  final int high;
  const Range(this.low, this.high);
}

enum ParticleType { bass, mid, treble }

class ParticleVelocityData {
  final double baseVelocity;
  final double turbulence;
  final Offset directionalBias;
  final double sizeMultiplier;
  
  ParticleVelocityData({
    required this.baseVelocity,
    required this.turbulence,
    required this.directionalBias,
    required this.sizeMultiplier,
  });
}

// ============================================================================
// 2. COMPLEX DASHBOARD LAYERS: NeonMusicDashboard
// ============================================================================

class NeonMusicDashboard extends StatefulWidget {
  final VisualAudioSynchronizer synchronizer;
  
  const NeonMusicDashboard({super.key, required this.synchronizer});
  
  @override
  State<NeonMusicDashboard> createState() => _NeonMusicDashboardState();
}

class _NeonMusicDashboardState extends State<NeonMusicDashboard> with SingleTickerProviderStateMixin {
  late AnimationController _pulseController;
  final List<Offset> _particlePositions = List.generate(200, (i) => Offset(
    Random().nextDouble() * 400,
    Random().nextDouble() * 400,
  ));
  
  @override
  void initState() {
    super.initState();
    _pulseController = AnimationController(
      vsync: this,
      duration: const Duration(milliseconds: 1500),
    )..repeat(reverse: true);
  }
  
  @override
  Widget build(BuildContext context) {
    return Stack(
      children: [
        // Layer 1: Background Grid
        CustomPaint(
          painter: _GridBackgroundPainter(
            intensity: widget.synchronizer.getMidEnergy(),
            pulseValue: _pulseController.value,
          ),
          size: Size.infinite,
        ),
        
        // Layer 2: Frequency Spectrum
        CustomPaint(
          painter: _SpectrumWavePainter(
            spectrumData: widget.synchronizer.getFrequencySpectrum(),
            bassEnergy: widget.synchronizer.getBassEnergy(),
            midEnergy: widget.synchronizer.getMidEnergy(),
            trebleEnergy: widget.synchronizer.getTrebleEnergy(),
          ),
        ),
        
        // Layer 3: Particle System
        CustomPaint(
          painter: _ParticleFieldPainter(
            positions: _particlePositions,
            synchronizer: widget.synchronizer,
          ),
        ),
        
        // Layer 4: Holographic Interface
        CustomPaint(
          painter: _HolographicOverlayPainter(
            beatProbability: widget.synchronizer.getBeatProbability(),
          ),
        ),
        
        // Layer 5: Animated Glitch Effects
        CustomPaint(
          painter: _GlitchEffectPainter(
            time: DateTime.now().millisecondsSinceEpoch / 1000,
            intensity: widget.synchronizer.getBeatProbability(),
          ),
        ),
        
        // Interactive Controls Overlay
        Positioned(
          bottom: 20,
          right: 20,
          child: ParticleDensityController(
            onDensityChanged: (density) {
              // Handle density change
            },
          ),
        ),
        
        Positioned(
          left: 20,
          bottom: 20,
          child: FuturisticEqualizer(
            synchronizer: widget.synchronizer,
          ),
        ),
      ],
    );
  }
}

// ============================================================================
// 2.1 Custom Painter Layers
// ============================================================================

class _GridBackgroundPainter extends CustomPainter {
  final double intensity;
  final double pulseValue;
  
  _GridBackgroundPainter({required this.intensity, required this.pulseValue});
  
  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()
      ..color = Colors.blue.withOpacity(0.1)
      ..strokeWidth = 1.0
      ..shader = LinearGradient(
        colors: [
          Colors.blue.withOpacity(0.05 + intensity * 0.1),
          Colors.purple.withOpacity(0.05 + intensity * 0.1),
        ],
      ).createShader(Rect.fromLTWH(0, 0, size.width, size.height));
    
    // Draw grid lines
    final gridSize = 40.0 + pulseValue * 10;
    for (double x = 0; x < size.width; x += gridSize) {
      canvas.drawLine(Offset(x, 0), Offset(x, size.height), paint);
    }
    for (double y = 0; y < size.height; y += gridSize) {
      canvas.drawLine(Offset(0, y), Offset(size.width, y), paint);
    }
    
    // Draw central pulse
    final pulseRadius = (size.width / 4) * (0.5 + pulseValue * 0.5);
    final pulsePaint = Paint()
      ..color = Colors.cyan.withOpacity(0.05 + intensity * 0.1)
      ..style = PaintingStyle.stroke
      ..strokeWidth = 2.0;
    
    canvas.drawCircle(
      Offset(size.width / 2, size.height / 2),
      pulseRadius,
      pulsePaint,
    );
  }
  
  @override
  bool shouldRepaint(covariant _GridBackgroundPainter oldDelegate) => true;
}

class _SpectrumWavePainter extends CustomPainter {
  final List<double> spectrumData;
  final double bassEnergy;
  final double midEnergy;
  final double trebleEnergy;
  
  _SpectrumWavePainter({
    required this.spectrumData,
    required this.bassEnergy,
    required this.midEnergy,
    required this.trebleEnergy,
  });
  
  @override
  void paint(Canvas canvas, Size size) {
    final path = Path();
    final barWidth = size.width / spectrumData.length;
    
    // Draw frequency bars
    for (int i = 0; i < spectrumData.length; i += 4) {
      final height = spectrumData[i] * size.height * 0.3;
      final x = i * barWidth;
      final y = size.height - height;
      
      // Color based on frequency range
      final Paint paint;
      if (i < spectrumData.length / 3) {
        paint = Paint()
          ..color = Color.lerp(Colors.red, Colors.orange, bassEnergy)!;
      } else if (i < spectrumData.length * 2 / 3) {
        paint = Paint()
          ..color = Color.lerp(Colors.green, Colors.yellow, midEnergy)!;
      } else {
        paint = Paint()
          ..color = Color.lerp(Colors.blue, Colors.purple, trebleEnergy)!;
      }
      
      paint
        ..shader = LinearGradient(
          colors: [paint.color, paint.color.withOpacity(0.3)],
          begin: Alignment.topCenter,
          end: Alignment.bottomCenter,
        ).createShader(Rect.fromLTWH(x, y, barWidth, height));
      
      final rect = Rect.fromLTWH(x, y, barWidth - 1, height);
      canvas.drawRect(rect, paint);
      
      // Add glow effect
      final glowPaint = Paint()
        ..color = paint.color.withOpacity(0.2)
        ..maskFilter = const MaskFilter.blur(BlurStyle.normal, 4.0);
      
      canvas.drawRect(rect.inflate(2), glowPaint);
    }
  }
  
  @override
  bool shouldRepaint(covariant _SpectrumWavePainter oldDelegate) => true;
}

class _ParticleFieldPainter extends CustomPainter {
  final List<Offset> positions;
  final VisualAudioSynchronizer synchronizer;
  
  _ParticleFieldPainter({
    required this.positions,
    required this.synchronizer,
  });
  
  @override
  void paint(Canvas canvas, Size size) {
    // Draw three particle types
    _drawParticleLayer(canvas, size, ParticleType.bass, 80);
    _drawParticleLayer(canvas, size, ParticleType.mid, 70);
    _drawParticleLayer(canvas, size, ParticleType.treble, 50);
  }
  
  void _drawParticleLayer(Canvas canvas, Size size, ParticleType type, int count) {
    final velocityData = synchronizer.calculateParticleVelocities(type);
    
    for (int i = 0; i < count; i++) {
      final basePos = positions[i % positions.length];
      final noiseX = sin(basePos.dx * 0.01 + DateTime.now().millisecondsSinceEpoch * 0.001);
      final noiseY = cos(basePos.dy * 0.01 + DateTime.now().millisecondsSinceEpoch * 0.001);
      
      final pos = Offset(
        (basePos.dx + noiseX * velocityData.turbulence) % size.width,
        (basePos.dy + noiseY * velocityData.turbulence) % size.height,
      );
      
      // Particle color based on type
      final Color color;
      switch (type) {
        case ParticleType.bass:
          color = Colors.red.withOpacity(0.6 + synchronizer.getBassEnergy() * 0.4);
          break;
        case ParticleType.mid:
          color = Colors.green.withOpacity(0.6 + synchronizer.getMidEnergy() * 0.4);
          break;
        case ParticleType.treble:
          color = Colors.blue.withOpacity(0.6 + synchronizer.getTrebleEnergy() * 0.4);
          break;
      }
      
      final paint = Paint()
        ..color = color
        ..maskFilter = const MaskFilter.blur(BlurStyle.normal, 8.0);
      
      final radius = 2.0 * velocityData.sizeMultiplier;
      canvas.drawCircle(pos, radius, paint);
      
      // Draw trail
      final trailPaint = Paint()
        ..color = color.withOpacity(0.3)
        ..strokeWidth = 1.0;
      
      final trailEnd = Offset(
        pos.dx - velocityData.directionalBias.dx * 10,
        pos.dy - velocityData.directionalBias.dy * 10,
      );
      
      canvas.drawLine(pos, trailEnd, trailPaint);
    }
  }
  
  @override
  bool shouldRepaint(covariant _ParticleFieldPainter oldDelegate) => true;
}

class _HolographicOverlayPainter extends CustomPainter {
  final double beatProbability;
  
  _HolographicOverlayPainter({required this.beatProbability});
  
  @override
  void paint(Canvas canvas, Size size) {
    // Draw holographic rings
    final ringPaint = Paint()
      ..style = PaintingStyle.stroke
      ..strokeWidth = 1.5
      ..shader = const LinearGradient(
        colors: [Colors.cyan, Colors.purple],
      ).createShader(Rect.fromCircle(
        center: Offset(size.width / 2, size.height / 2),
        radius: size.width / 3,
      ));
    
    for (int i = 0; i < 5; i++) {
      final radius = size.width / 4 + i * 20 + beatProbability * 30;
      final opacity = 0.3 - i * 0.05 + beatProbability * 0.3;
      
      ringPaint.color = ringPaint.color.withOpacity(opacity);
      
      canvas.drawCircle(
        Offset(size.width / 2, size.height / 2),
        radius,
        ringPaint,
      );
    }
    
    // Draw frequency indicators
    final indicatorPaint = Paint()
      ..color = Colors.white.withOpacity(0.1 + beatProbability * 0.2);
    
    for (double angle = 0; angle < 2 * pi; angle += pi / 8) {
      final x = size.width / 2 + cos(angle) * size.width / 3;
      final y = size.height / 2 + sin(angle) * size.height / 3;
      
      canvas.drawCircle(
        Offset(x, y),
        2.0 + beatProbability * 4,
        indicatorPaint,
      );
    }
  }
  
  @override
  bool shouldRepaint(covariant _HolographicOverlayPainter oldDelegate) => true;
}

class _GlitchEffectPainter extends CustomPainter {
  final double time;
  final double intensity;
  
  _GlitchEffectPainter({required this.time, required this.intensity});
  
  @override
  void paint(Canvas canvas, Size size) {
    if (intensity < 0.3) return;
    
    // Generate random glitch lines
    final random = Random((time * 1000).toInt());
    final glitchPaint = Paint()
      ..color = Colors.white.withOpacity(intensity * 0.3)
      ..strokeWidth = 1.0;
    
    for (int i = 0; i < (intensity * 10).toInt(); i++) {
      final y = random.nextDouble() * size.height;
      final height = random.nextDouble() * 5;
      final offset = (random.nextDouble() * 10 - 5) * intensity;
      
      canvas.drawRect(
        Rect.fromLTWH(offset, y, size.width, height),
        glitchPaint,
      );
    }
    
    // Color shift effect
    if (intensity > 0.7) {
      final colorShiftPaint = Paint()
        ..colorFilter = ColorFilter.matrix([
          1, 0, 0, 0, 0,
          0, 0, 1, 0, 0,
          0, 1, 0, 0, 0,
          0, 0, 0, 1, 0,
        ])
        ..blendMode = BlendMode.plus;
      
      canvas.saveLayer(null, colorShiftPaint);
      canvas.restore();
    }
  }
  
  @override
  bool shouldRepaint(covariant _GlitchEffectPainter oldDelegate) => true;
}

// ============================================================================
// 3. UNIQUE UI WIDGETS
// ============================================================================

class FuturisticEqualizer extends StatefulWidget {
  final VisualAudioSynchronizer synchronizer;
  
  const FuturisticEqualizer({super.key, required this.synchronizer});
  
  @override
  State<FuturisticEqualizer> createState() => _FuturisticEqualizerState();
}

class _FuturisticEqualizerState extends State<FuturisticEqualizer> with SingleTickerProviderStateMixin {
  late AnimationController _animationController;
  final List<double> _bandValues = List.filled(16, 0.0);
  
  @override
  void initState() {
    super.initState();
    _animationController = AnimationController(
      duration: const Duration(milliseconds: 100),
      vsync: this,
    )..repeat();
  }
  
  @override
  Widget build(BuildContext context) {
    return AnimatedBuilder(
      animation: _animationController,
      builder: (context, child) {
        // Update band values from synchronizer
        final spectrum = widget.synchronizer.getFrequencySpectrum();
        for (int i = 0; i < _bandValues.length; i++) {
          final index = (i * spectrum.length ~/ _bandValues.length);
          _bandValues[i] = spectrum[index] * 0.5 + _bandValues[i] * 0.5;
        }
        
        return Container(
          width: 300,
          height: 120,
          decoration: BoxDecoration(
            color: Colors.black.withOpacity(0.7),
            borderRadius: BorderRadius.circular(20),
            border: Border.all(
              color: Colors.cyan.withOpacity(0.5),
              width: 1.0,
            ),
          ),
          child: CustomPaint(
            painter: _EqualizerPainter(
              bandValues: _bandValues,
              bassEnergy: widget.synchronizer.getBassEnergy(),
              beatProbability: widget.synchronizer.getBeatProbability(),
            ),
          ),
        );
      },
    );
  }
}

class _EqualizerPainter extends CustomPainter {
  final List<double> bandValues;
  final double bassEnergy;
  final double beatProbability;
  
  _EqualizerPainter({
    required this.bandValues,
    required this.bassEnergy,
    required this.beatProbability,
  });
  
  @override
  void paint(Canvas canvas, Size size) {
    final barWidth = size.width / bandValues.length;
    final maxHeight = size.height * 0.8;
    
    // Draw bars with gradient
    for (int i = 0; i < bandValues.length; i++) {
      final height = bandValues[i] * maxHeight;
      final x = i * barWidth + barWidth / 2;
      final y = size.height - height;
      
      // Create animated gradient
      final gradient = LinearGradient(
        colors: [
          Colors.red.withOpacity(0.8 + bassEnergy * 0.2),
          Colors.yellow.withOpacity(0.6),
          Colors.green.withOpacity(0.8),
          Colors.blue.withOpacity(0.8 + beatProbability * 0.2),
        ],
        stops: const [0.0, 0.3, 0.6, 1.0],
      );
      
      final paint = Paint()
        ..shader = gradient.createShader(Rect.fromLTWH(x - barWidth/2, y, barWidth, height))
        ..maskFilter = const MaskFilter.blur(BlurStyle.normal, 2.0);
      
      // Draw rounded bar
      final barRect = Rect.fromLTWH(
        x - barWidth/2 + 1,
        y,
        barWidth - 2,
        height,
      );
      
      final roundedRect = RRect.fromRectAndRadius(barRect, Radius.circular(barWidth/2));
      canvas.drawRRect(roundedRect, paint);
      
      // Draw peak indicator
      if (bandValues[i] > 0.9) {
        final peakPaint = Paint()
          ..color = Colors.white.withOpacity(beatProbability)
          ..strokeWidth = 1.0;
        
        canvas.drawLine(
          Offset(x, y - 5),
          Offset(x, y + 5),
          peakPaint,
        );
      }
    }
    
    // Draw frequency labels
    final textStyle = TextStyle(
      color: Colors.cyan.withOpacity(0.7),
      fontSize: 10,
    );
    
    final textPainter = TextPainter(
      textDirection: TextDirection.ltr,
    );
    
    final frequencies = ['20Hz', '250', '1K', '4K', '20K'];
    for (int i = 0; i < frequencies.length; i++) {
      final x = (i * bandValues.length / (frequencies.length - 1)) * barWidth;
      textPainter.text = TextSpan(text: frequencies[i], style: textStyle);
      textPainter.layout();
      textPainter.paint(canvas, Offset(x, size.height - 15));
    }
  }
  
  @override
  bool shouldRepaint(covariant _EqualizerPainter oldDelegate) => true;
}

class GravitySlider extends StatefulWidget {
  final double initialValue;
  final ValueChanged<double> onChanged;
  final String label;
  
  const GravitySlider({
    super.key,
    this.initialValue = 0.5,
    required this.onChanged,
    required this.label,
  });
  
  @override
  State<GravitySlider> createState() => _GravitySliderState();
}

class _GravitySliderState extends State<GravitySlider> with SingleTickerProviderStateMixin {
  late double _value;
  late AnimationController _gravityController;
  late Animation<double> _gravityAnimation;
  double _particleY = 0;
  
  @override
  void initState() {
    super.initState();
    _value = widget.initialValue;
    _gravityController = AnimationController(
      duration: const Duration(milliseconds: 2000),
      vsync: this,
    )..repeat(reverse: true);
    
    _gravityAnimation = Tween<double>(begin: 0, end: 1).animate(
      CurvedAnimation(parent: _gravityController, curve: Curves.easeInOut),
    );
  }
  
  @override
  Widget build(BuildContext context) {
    return AnimatedBuilder(
      animation: _gravityAnimation,
      builder: (context, child) {
        _particleY = sin(_gravityAnimation.value * pi * 2) * 10 * _value;
        
        return Container(
          width: 250,
          height: 80,
          decoration: BoxDecoration(
            borderRadius: BorderRadius.circular(40),
            gradient: LinearGradient(
              colors: [
                Colors.black.withOpacity(0.9),
                Colors.grey[900]!,
              ],
              begin: Alignment.topLeft,
              end: Alignment.bottomRight,
            ),
            border: Border.all(
              color: Colors.cyan.withOpacity(0.5),
              width: 1.5,
            ),
            boxShadow: [
              BoxShadow(
                color: Colors.cyan.withOpacity(0.3),
                blurRadius: 10,
                spreadRadius: 2,
              ),
            ],
          ),
          child: Stack(
            children: [
              // Slider track
              Positioned(
                left: 20,
                right: 20,
                top: 40,
                child: Container(
                  height: 4,
                  decoration: BoxDecoration(
                    gradient: LinearGradient(
                      colors: [
                        Colors.red.withOpacity(0.8),
                        Colors.yellow.withOpacity(0.8),
                        Colors.green.withOpacity(0.8),
                        Colors.blue.withOpacity(0.8),
                      ],
                    ),
                    borderRadius: BorderRadius.circular(2),
                  ),
                ),
              ),
              
              // Gravity particles
              Positioned(
                left: 20 + _value * 210,
                top: 20 + _particleY,
                child: Container(
                  width: 24,
                  height: 24,
                  decoration: BoxDecoration(
                    shape: BoxShape.circle,
                    gradient: RadialGradient(
                      colors: [
                        Colors.cyan.withOpacity(1.0),
                        Colors.cyan.withOpacity(0.3),
                      ],
                    ),
                    boxShadow: [
                      BoxShadow(
                        color: Colors.cyan.withOpacity(0.8),
                        blurRadius: 10,
                      ),
                    ],
                  ),
                ),
              ),
              
              // Slider thumb with custom gesture detector
              Positioned.fill(
                child: GestureDetector(
                  onPanUpdate: (details) {
                    final newValue = (_value + details.delta.dx / 200).clamp(0.0, 1.0);
                    setState(() => _value = newValue);
                    widget.onChanged(newValue);
                  },
                  behavior: HitTestBehavior.translucent,
                ),
              ),
              
              // Label
              Positioned(
                left: 20,
                top: 10,
                child: Text(
                  widget.label,
                  style: TextStyle(
                    color: Colors.cyan.withOpacity(0.9),
                    fontSize: 12,
                    fontWeight: FontWeight.bold,
                  ),
                ),
              ),
              
              // Value indicator
              Positioned(
                right: 20,
                top: 10,
                child: Text(
                  '${(_value * 100).toInt()}%',
                  style: TextStyle(
                    color: Colors.white.withOpacity(0.8),
                    fontSize: 12,
                  ),
                ),
              ),
            ],
          ),
        );
      },
    );
  }
}

class ParticleDensityController extends StatefulWidget {
  final ValueChanged<int> onDensityChanged;
  
  const ParticleDensityController({super.key, required this.onDensityChanged});
  
  @override
  State<ParticleDensityController> createState() => _ParticleDensityControllerState();
}

class _ParticleDensityControllerState extends State<ParticleDensityController> with TickerProviderStateMixin {
  int _density = 3; // 1-5 scale
  late List<AnimationController> _particleControllers;
  final List<Offset> _particlePositions = [];
  
  @override
  void initState() {
    super.initState();
    _initializeParticles();
  }
  
  void _initializeParticles() {
    _particlePositions.clear();
    final random = Random();
    for (int i = 0; i < 30; i++) {
      _particlePositions.add(Offset(
        random.nextDouble() * 100,
        random.nextDouble() * 60,
      ));
    }
    
    _particleControllers = List.generate(
      _density * 6,
      (i) => AnimationController(
        duration: Duration(milliseconds: 1000 + random.nextInt(1000)),
        vsync: this,
      )..repeat(reverse: true),
    );
  }
  
  void _updateDensity(int newDensity) {
    setState(() {
      _density = newDensity;
      _initializeParticles();
    });
    widget.onDensityChanged(newDensity * 50); // Convert to particle count
  }
  
  @override
  Widget build(BuildContext context) {
    return Container(
      width: 120,
      height: 180,
      decoration: BoxDecoration(
        color: Colors.black.withOpacity(0.8),
        borderRadius: BorderRadius.circular(20),
        border: Border.all(
          color: Colors.purple.withOpacity(0.6),
          width: 1.0,
        ),
      ),
      child: Column(
        children: [
          // Title
          Padding(
            padding: const EdgeInsets.only(top: 12.0),
            child: Text(
              'PARTICLE\nDENSITY',
              textAlign: TextAlign.center,
              style: TextStyle(
                color: Colors.purple.withOpacity(0.9),
                fontSize: 10,
                fontWeight: FontWeight.bold,
                letterSpacing: 1.5,
              ),
            ),
          ),
          
          // Interactive particle display
          Expanded(
            child: Stack(
              children: [
                // Background grid
                CustomPaint(
                  painter: _DensityGridPainter(density: _density),
                ),
                
                // Animated particles
                for (int i = 0; i < _particleControllers.length; i++)
                  AnimatedBuilder(
                    animation: _particleControllers[i],
                    builder: (context, child) {
                      final progress = _particleControllers[i].value;
                      final pos = _particlePositions[i % _particlePositions.length];
                      
                      return Positioned(
                        left: pos.dx + sin(progress * pi * 2) * 10,
                        top: pos.dy + cos(progress * pi * 2) * 10,
                        child: Container(
                          width: 3 + _density.toDouble(),
                          height: 3 + _density.toDouble(),
                          decoration: BoxDecoration(
                            shape: BoxShape.circle,
                            gradient: RadialGradient(
                              colors: [
                                Colors.purple.withOpacity(0.9),
                                Colors.purple.withOpacity(0.1),
                              ],
                            ),
                            boxShadow: [
                              BoxShadow(
                                color: Colors.purple.withOpacity(0.5),
                                blurRadius: 4,
                              ),
                            ],
                          ),
                        ),
                      );
                    },
                  ),
              ],
            ),
          ),
          
          // Density selector
          Padding(
            padding: const EdgeInsets.only(bottom: 12.0),
            child: Row(
              mainAxisAlignment: MainAxisAlignment.spaceEvenly,
              children: List.generate(5, (index) {
                final level = index + 1;
                return GestureDetector(
                  onTap: () => _updateDensity(level),
                  child: Container(
                    width: 16,
                    height: 16,
                    decoration: BoxDecoration(
                      shape: BoxShape.circle,
                      color: level <= _density
                          ? Colors.purple.withOpacity(0.8)
                          : Colors.grey.withOpacity(0.3),
                      border: Border.all(
                        color: Colors.white.withOpacity(0.5),
                        width: 1.0,
                      ),
                    ),
                    child: level <= _density
                        ? Center(
                            child: Container(
                              width: 6,
                              height: 6,
                              decoration: const BoxDecoration(
                                shape: BoxShape.circle,
                                color: Colors.white,
                              ),
                            ),
                          )
                        : null,
                  ),
                );
              }),
            ),
          ),
        ],
      ),
    );
  }
}

class _DensityGridPainter extends CustomPainter {
  final int density;
  
  _DensityGridPainter({required this.density});
  
  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()
      ..color = Colors.purple.withOpacity(0.1)
      ..strokeWidth = 0.5;
    
    final gridSize = 20 - density * 2;
    for (double x = 0; x < size.width; x += gridSize) {
      canvas.drawLine(Offset(x, 0), Offset(x, size.height), paint);
    }
    for (double y = 0; y < size.height; y += gridSize) {
      canvas.drawLine(Offset(0, y), Offset(size.width, y), paint);
    }
  }
  
  @override
  bool shouldRepaint(covariant _DensityGridPainter oldDelegate) => true;
}
// File: lib/main_core.dart (PART 2)
// SECTION: INTERNAL SCREENS
// SUBSECTION: VISUAL ENGINE CONFIGURATION INTERFACE

class VisualizerSettingsScreen extends StatefulWidget {
  final VisualEngineConfiguration currentVisualEngineConfiguration;
  final Function(VisualEngineConfiguration) onVisualEngineConfigurationUpdated;
  
  const VisualizerSettingsScreen({
    Key? key,
    required this.currentVisualEngineConfiguration,
    required this.onVisualEngineConfigurationUpdated,
  }) : super(key: key);

  @override
  _VisualizerSettingsScreenState createState() => _VisualizerSettingsScreenState();
}

class _VisualizerSettingsScreenState extends State<VisualizerSettingsScreen> with SingleTickerProviderStateMixin {
  late VisualEngineConfiguration _workingVisualEngineConfiguration;
  late TabController _visualEngineConfigurationTabController;
  final _scrollControllerForVisualSettings = ScrollController();
  final _formKeyForVisualSettingsGlobalForm = GlobalKey<FormState>();
  final Map<String, FocusNode> _focusNodeMappingForVisualSettingsInputFields = {};
  final Map<String, TextEditingController> _textEditingControllerMappingForVisualSettingsInputFields = {};

  @override
  void initState() {
    super.initState();
    _workingVisualEngineConfiguration = widget.currentVisualEngineConfiguration.deepCopy();
    _visualEngineConfigurationTabController = TabController(
      length: 7,
      vsync: this,
      initialIndex: 0,
    );
    _initializeFocusNodesAndTextControllersForAllVisualSettingsInputFields();
  }

  void _initializeFocusNodesAndTextControllersForAllVisualSettingsInputFields() {
    final List<String> allVisualSettingsFieldIdentifiers = [
      'particleMaximumLifetimeMilliseconds',
      'particleMinimumLifetimeMilliseconds',
      'particleSpawnRatePerSecond',
      'particleBaseSizeMultiplier',
      'particleVelocityDampingFactor',
      'particleGravitationalConstant',
      'particleChargedInteractionStrength',
      'particleColorTransitionSpeed',
      'particleOpacityDecayExponent',
      'windForceMagnitudeXAxis',
      'windForceMagnitudeYAxis',
      'windForceTurbulenceFrequency',
      'windForceTurbulenceAmplitude',
      'windForceDirectionalBias',
      'bloomEffectRadiusMultiplier',
      'bloomEffectIntensityScalar',
      'bloomEffectThresholdLuminance',
      'bloomEffectDiffusionIterations',
      'trailEffectLengthInFrames',
      'trailEffectOpacityDecayCurveExponent',
      'trailEffectWidthScaleFactor',
      'trailEffectColorBlendModeIndex',
      'waveformVisualizationBarCount',
      'waveformVisualizationBarRoundingRadius',
      'waveformVisualizationBarSpacingFactor',
      'waveformVisualizationBarHeightMultiplier',
      'waveformVisualizationSmoothingFactor',
      'spectrumAnalyzerFrequencyBandCount',
      'spectrumAnalyzerFalloffSpeed',
      'spectrumAnalyzerPeakHoldDuration',
      'spectrumAnalyzerBarWidthRatio',
      'colorSchemeHueRotationDegrees',
      'colorSchemeSaturationBoost',
      'colorSchemeValueBoost',
      'colorSchemeBackgroundOpacity',
      'colorSchemePrimaryGradientStopsCount',
      'colorSchemeSecondaryGradientStopsCount',
      'colorSchemeTertiaryGradientStopsCount',
      'renderingTargetFrameRateCap',
      'renderingParticleCountMaximumLimit',
      'renderingGeometryComplexityLevel',
      'renderingAntialiasingQualitySetting',
      'renderingTextureFilteringModeIndex',
      'audioReactiveSensitivityGainDb',
      'audioReactiveAttackTimeMilliseconds',
      'audioReactiveReleaseTimeMilliseconds',
      'audioReactiveLowFrequencyWeight',
      'audioReactiveMidFrequencyWeight',
      'audioReactiveHighFrequencyWeight',
      'audioReactiveThresholdGateLevel',
      'audioReactiveCompressionRatio',
      'audioReactiveKneeWidthSoftness',
    ];

    for (final fieldIdentifier in allVisualSettingsFieldIdentifiers) {
      _focusNodeMappingForVisualSettingsInputFields[fieldIdentifier] = FocusNode();
      _textEditingControllerMappingForVisualSettingsInputFields[fieldIdentifier] = TextEditingController();
    }
  }

  Widget _buildParticleSystemConfigurationSettingsExpansionPanel() {
    return ExpansionPanel(
      headerBuilder: (BuildContext context, bool isExpanded) {
        return ListTile(
          leading: Icon(Icons.polyline, size: 28.0, color: Colors.cyanAccent.shade400),
          title: Text(
            'Particle Life Configuration Parameters',
            style: TextStyle(
              fontSize: 18.0,
              fontWeight: FontWeight.w700,
              letterSpacing: 0.5,
              color: Colors.white.withOpacity(0.95),
            ),
          ),
          subtitle: Text(
            'Control particle lifespan, spawn rates, physical interactions',
            style: TextStyle(
              fontSize: 14.0,
              fontWeight: FontWeight.w400,
              letterSpacing: 0.25,
              color: Colors.white.withOpacity(0.7),
            ),
          ),
        );
      },
      body: Container(
        padding: const EdgeInsets.symmetric(vertical: 20.0, horizontal: 16.0),
        decoration: BoxDecoration(
          gradient: LinearGradient(
            begin: Alignment.topLeft,
            end: Alignment.bottomRight,
            colors: [
              Colors.blueGrey.shade900.withOpacity(0.6),
              Colors.blueGrey.shade800.withOpacity(0.3),
            ],
          ),
          borderRadius: const BorderRadius.vertical(bottom: Radius.circular(12.0)),
        ),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            _buildSliderWithLabelAndTextField(
              labelText: 'Particle Maximum Lifetime Milliseconds',
              currentValue: _workingVisualEngineConfiguration.particleMaximumLifetimeMilliseconds,
              minValue: 100.0,
              maxValue: 10000.0,
              divisions: 990,
              onChanged: (double newValue) {
                setState(() {
                  _workingVisualEngineConfiguration.particleMaximumLifetimeMilliseconds = newValue;
                });
              },
              measurementUnit: 'ms',
              fieldIdentifier: 'particleMaximumLifetimeMilliseconds',
            ),
            const SizedBox(height: 18.0),
            _buildSliderWithLabelAndTextField(
              labelText: 'Particle Minimum Lifetime Milliseconds',
              currentValue: _workingVisualEngineConfiguration.particleMinimumLifetimeMilliseconds,
              minValue: 50.0,
              maxValue: 5000.0,
              divisions: 4950,
              onChanged: (double newValue) {
                setState(() {
                  _workingVisualEngineConfiguration.particleMinimumLifetimeMilliseconds = newValue;
                });
              },
              measurementUnit: 'ms',
              fieldIdentifier: 'particleMinimumLifetimeMilliseconds',
            ),
            const SizedBox(height: 18.0),
            _buildSliderWithLabelAndTextField(
              labelText: 'Particle Spawn Rate Per Second',
              currentValue: _workingVisualEngineConfiguration.particleSpawnRatePerSecond,
              minValue: 1.0,
              maxValue: 500.0,
              divisions: 499,
              onChanged: (double newValue) {
                setState(() {
                  _workingVisualEngineConfiguration.particleSpawnRatePerSecond = newValue;
                });
              },
              measurementUnit: 'particles/sec',
              fieldIdentifier: 'particleSpawnRatePerSecond',
            ),
            const SizedBox(height: 18.0),
            _buildSliderWithLabelAndTextField(
              labelText: 'Particle Base Size Multiplier',
              currentValue: _workingVisualEngineConfiguration.particleBaseSizeMultiplier,
              minValue: 0.1,
              maxValue: 10.0,
              divisions: 990,
              onChanged: (double newValue) {
                setState(() {
                  _workingVisualEngineConfiguration.particleBaseSizeMultiplier = newValue;
                });
              },
              measurementUnit: 'x',
              fieldIdentifier: 'particleBaseSizeMultiplier',
            ),
            const SizedBox(height: 18.0),
            _buildSliderWithLabelAndTextField(
              labelText: 'Particle Velocity Damping Factor',
              currentValue: _workingVisualEngineConfiguration.particleVelocityDampingFactor,
              minValue: 0.01,
              maxValue: 1.0,
              divisions: 990,
              onChanged: (double newValue) {
                setState(() {
                  _workingVisualEngineConfiguration.particleVelocityDampingFactor = newValue;
                });
              },
              measurementUnit: 'coefficient',
              fieldIdentifier: 'particleVelocityDampingFactor',
            ),
            const SizedBox(height: 18.0),
            _buildSliderWithLabelAndTextField(
              labelText: 'Particle Gravitational Constant',
              currentValue: _workingVisualEngineConfiguration.particleGravitationalConstant,
              minValue: -10.0,
              maxValue: 10.0,
              divisions: 2000,
              onChanged: (double newValue) {
                setState(() {
                  _workingVisualEngineConfiguration.particleGravitationalConstant = newValue;
                });
              },
              measurementUnit: 'G',
              fieldIdentifier: 'particleGravitationalConstant',
            ),
            const SizedBox(height: 18.0),
            _buildSliderWithLabelAndTextField(
              labelText: 'Particle Charged Interaction Strength',
              currentValue: _workingVisualEngineConfiguration.particleChargedInteractionStrength,
              minValue: -5.0,
              maxValue: 5.0,
              divisions: 1000,
              onChanged: (double newValue) {
                setState(() {
                  _workingVisualEngineConfiguration.particleChargedInteractionStrength = newValue;
                });
              },
              measurementUnit: 'q',
              fieldIdentifier: 'particleChargedInteractionStrength',
            ),
            const SizedBox(height: 18.0),
            _buildSliderWithLabelAndTextField(
              labelText: 'Particle Color Transition Speed',
              currentValue: _workingVisualEngineConfiguration.particleColorTransitionSpeed,
              minValue: 0.0,
              maxValue: 1.0,
              divisions: 1000,
              onChanged: (double newValue) {
                setState(() {
                  _workingVisualEngineConfiguration.particleColorTransitionSpeed = newValue;
                });
              },
              measurementUnit: 'Δt',
              fieldIdentifier: 'particleColorTransitionSpeed',
            ),
            const SizedBox(height: 18.0),
            _buildSliderWithLabelAndTextField(
              labelText: 'Particle Opacity Decay Exponent',
              currentValue: _workingVisualEngineConfiguration.particleOpacityDecayExponent,
              minValue: 0.5,
              maxValue: 3.0,
              divisions: 250,
              onChanged: (double newValue) {
                setState(() {
                  _workingVisualEngineConfiguration.particleOpacityDecayExponent = newValue;
                });
              },
              measurementUnit: 'γ',
              fieldIdentifier: 'particleOpacityDecayExponent',
            ),
          ],
        ),
      ),
      isExpanded: true,
    );
  }

  Widget _buildEnvironmentalForcesConfigurationSettingsExpansionPanel() {
    return ExpansionPanel(
      headerBuilder: (BuildContext context, bool isExpanded) {
        return ListTile(
          leading: Icon(Icons.air, size: 28.0, color: Colors.lightBlueAccent.shade400),
          title: Text(
            'Environmental Forces Configuration Parameters',
            style: TextStyle(
              fontSize: 18.0,
              fontWeight: FontWeight.w700,
              letterSpacing: 0.5,
              color: Colors.white.withOpacity(0.95),
            ),
          ),
          subtitle: Text(
            'Wind forces, turbulence, directional biases affecting particle motion',
            style: TextStyle(
              fontSize: 14.0,
              fontWeight: FontWeight.w400,
              letterSpacing: 0.25,
              color: Colors.white.withOpacity(0.7),
            ),
          ),
        );
      },
      body: Container(
        padding: const EdgeInsets.symmetric(vertical: 20.0, horizontal: 16.0),
        decoration: BoxDecoration(
          gradient: LinearGradient(
            begin: Alignment.topLeft,
            end: Alignment.bottomRight,
            colors: [
              Colors.blueGrey.shade900.withOpacity(0.6),
              Colors.blueGrey.shade800.withOpacity(0.3),
            ],
          ),
          borderRadius: const BorderRadius.vertical(bottom: Radius.circular(12.0)),
        ),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            _buildSliderWithLabelAndTextField(
              labelText: 'Wind Force Magnitude X-Axis',
              currentValue: _workingVisualEngineConfiguration.windForceMagnitudeXAxis,
              minValue: -2.0,
              maxValue: 2.0,
              divisions: 400,
              onChanged: (double newValue) {
                setState(() {
                  _workingVisualEngineConfiguration.windForceMagnitudeXAxis = newValue;
                });
              },
              measurementUnit: 'm/s²',
              fieldIdentifier: 'windForceMagnitudeXAxis',
            ),
            const SizedBox(height: 18.0),
            _buildSliderWithLabelAndTextField(
              labelText: 'Wind Force Magnitude Y-Axis',
              currentValue: _workingVisualEngineConfiguration.windForceMagnitudeYAxis,
              minValue: -2.0,
              maxValue: 2.0,
              divisions: 400,
              onChanged: (double newValue) {
                setState(() {
                  _workingVisualEngineConfiguration.windForceMagnitudeYAxis = newValue;
                });
              },
              measurementUnit: 'm/s²',
              fieldIdentifier: 'windForceMagnitudeYAxis',
            ),
            const SizedBox(height: 18.0),
            _buildSliderWithLabelAndTextField(
              labelText: 'Wind Force Turbulence Frequency',
              currentValue: _workingVisualEngineConfiguration.windForceTurbulenceFrequency,
              minValue: 0.0,
              maxValue: 10.0,
              divisions: 1000,
              onChanged: (double newValue) {
                setState(() {
                  _workingVisualEngineConfiguration.windForceTurbulenceFrequency = newValue;
                });
              },
              measurementUnit: 'Hz',
              fieldIdentifier: 'windForceTurbulenceFrequency',
            ),
            const SizedBox(height: 18.0),
            _buildSliderWithLabelAndTextField(
              labelText: 'Wind Force Turbulence Amplitude',
              currentValue: _workingVisualEngineConfiguration.windForceTurbulenceAmplitude,
              minValue: 0.0,
              maxValue: 1.0,
              divisions: 1000,
              onChanged: (double newValue) {
                setState(() {
                  _workingVisualEngineConfiguration.windForceTurbulenceAmplitude = newValue;
                });
              },
              measurementUnit: 'A',
              fieldIdentifier: 'windForceTurbulenceAmplitude',
            ),
            const SizedBox(height: 18.0),
            _buildSliderWithLabelAndTextField(
              labelText: 'Wind Force Directional Bias',
              currentValue: _workingVisualEngineConfiguration.windForceDirectionalBias,
              minValue: -1.0,
              maxValue: 1.0,
              divisions: 2000,
              onChanged: (double newValue) {
                setState(() {
                  _workingVisualEngineConfiguration.windForceDirectionalBias = newValue;
                });
              },
              measurementUnit: 'θ',
              fieldIdentifier: 'windForceDirectionalBias',
            ),
          ],
        ),
      ),
      isExpanded: true,
    );
  }

  Widget _buildVisualEffectsConfigurationSettingsExpansionPanel() {
    return ExpansionPanel(
      headerBuilder: (BuildContext context, bool isExpanded) {
        return ListTile(
          leading: Icon(Icons.blur_on, size: 28.0, color: Colors.purpleAccent.shade400),
          title: Text(
            'Visual Effects Configuration Parameters',
            style: TextStyle(
              fontSize: 18.0,
              fontWeight: FontWeight.w700,
              letterSpacing: 0.5,
              color: Colors.white.withOpacity(0.95),
            ),
          ),
          subtitle: Text(
            'Bloom, trail effects, glow parameters and post-processing settings',
            style: TextStyle(
              fontSize: 14.0,
              fontWeight: FontWeight.w400,
              letterSpacing: 0.25,
              color: Colors.white.withOpacity(0.7),
            ),
          ),
        );
      },
      body: Container(
        padding: const EdgeInsets.symmetric(vertical: 20.0, horizontal: 16.0),
        decoration: BoxDecoration(
          gradient: LinearGradient(
            begin: Alignment.topLeft,
            end: Alignment.bottomRight,
            colors: [
              Colors.blueGrey.shade900.withOpacity(0.6),
              Colors.blueGrey.shade800.withOpacity(0.3),
            ],
          ),
          borderRadius: const BorderRadius.vertical(bottom: Radius.circular(12.0)),
        ),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            _buildSliderWithLabelAndTextField(
              labelText: 'Bloom Effect Radius Multiplier',
              currentValue: _workingVisualEngineConfiguration.bloomEffectRadiusMultiplier,
              minValue: 0.0,
              maxValue: 5.0,
              divisions: 500,
              onChanged: (double newValue) {
                setState(() {
                  _workingVisualEngineConfiguration.bloomEffectRadiusMultiplier = newValue;
                });
              },
              measurementUnit: 'r',
              fieldIdentifier: 'bloomEffectRadiusMultiplier',
            ),
            const SizedBox(height: 18.0),
            _buildSliderWithLabelAndTextField(
              labelText: 'Bloom Effect Intensity Scalar',
              currentValue: _workingVisualEngineConfiguration.bloomEffectIntensityScalar,
              minValue: 0.0,
              maxValue: 3.0,
              divisions: 300,
              onChanged: (double newValue) {
                setState(() {
                  _workingVisualEngineConfiguration.bloomEffectIntensityScalar = newValue;
                });
              },
              measurementUnit: 'I',
              fieldIdentifier: 'bloomEffectIntensityScalar',
            ),
            const SizedBox(height: 18.0),
            _buildSliderWithLabelAndTextField(
              labelText: 'Bloom Effect Threshold Luminance',
              currentValue: _workingVisualEngineConfiguration.bloomEffectThresholdLuminance,
              minValue: 0.0,
              maxValue: 1.0,
              divisions: 1000,
              onChanged: (double newValue) {
                setState(() {
                  _workingVisualEngineConfiguration.bloomEffectThresholdLuminance = newValue;
                });
              },
              measurementUnit: 'L',
              fieldIdentifier: 'bloomEffectThresholdLuminance',
            ),
            const SizedBox(height: 18.0),
            _buildSliderWithLabelAndTextField(
              labelText: 'Bloom Effect Diffusion Iterations',
              currentValue: _workingVisualEngineConfiguration.bloomEffectDiffusionIterations.toDouble(),
              minValue: 1.0,
              maxValue: 10.0,
              divisions: 9,
              onChanged: (double newValue) {
                setState(() {
                  _workingVisualEngineConfiguration.bloomEffectDiffusionIterations = newValue.round();
                });
              },
              measurementUnit: 'passes',
              fieldIdentifier: 'bloomEffectDiffusionIterations',
            ),
            const SizedBox(height: 18.0),
            _buildSliderWithLabelAndTextField(
              labelText: 'Trail Effect Length In Frames',
              currentValue: _workingVisualEngineConfiguration.trailEffectLengthInFrames.toDouble(),
              minValue: 1.0,
              maxValue: 120.0,
              divisions: 119,
              onChanged: (double newValue) {
                setState(() {
                  _workingVisualEngineConfiguration.trailEffectLengthInFrames = newValue.round();
                });
              },
              measurementUnit: 'frames',
              fieldIdentifier: 'trailEffectLengthInFrames',
            ),
            const SizedBox(height: 18.0),
            _buildSliderWithLabelAndTextField(
              labelText: 'Trail Effect Opacity Decay Curve Exponent',
              currentValue: _workingVisualEngineConfiguration.trailEffectOpacityDecayCurveExponent,
              minValue: 0.1,
              maxValue: 5.0,
              divisions: 490,
              onChanged: (double newValue) {
                setState(() {
                  _workingVisualEngineConfiguration.trailEffectOpacityDecayCurveExponent = newValue;
                });
              },
              measurementUnit: 'α',
              fieldIdentifier: 'trailEffectOpacityDecayCurveExponent',
            ),
            const SizedBox(height: 18.0),
            _buildSliderWithLabelAndTextField(
              labelText: 'Trail Effect Width Scale Factor',
              currentValue: _workingVisualEngineConfiguration.trailEffectWidthScaleFactor,
              minValue: 0.1,
              maxValue: 3.0,
              divisions: 290,
              onChanged: (double newValue) {
                setState(() {
                  _workingVisualEngineConfiguration.trailEffectWidthScaleFactor = newValue;
                });
              },
              measurementUnit: 'w',
              fieldIdentifier: 'trailEffectWidthScaleFactor',
            ),
            const SizedBox(height: 18.0),
            _buildSliderWithLabelAndTextField(
              labelText: 'Trail Effect Color Blend Mode Index',
              currentValue: _workingVisualEngineConfiguration.trailEffectColorBlendModeIndex.toDouble(),
              minValue: 0.0,
              maxValue: 10.0,
              divisions: 10,
              onChanged: (double newValue) {
                setState(() {
                  _workingVisualEngineConfiguration.trailEffectColorBlendModeIndex = newValue.round();
                });
              },
              measurementUnit: 'mode',
              fieldIdentifier: 'trailEffectColorBlendModeIndex',
            ),
          ],
        ),
      ),
      isExpanded: true,
    );
  }

  Widget _buildSliderWithLabelAndTextField({
    required String labelText,
    required double currentValue,
    required double minValue,
    required double maxValue,
    required int divisions,
    required Function(double) onChanged,
    required String measurementUnit,
    required String fieldIdentifier,
  }) {
    final TextEditingController textController = _textEditingControllerMappingForVisualSettingsInputFields[fieldIdentifier]!;
    final FocusNode focusNode = _focusNodeMappingForVisualSettingsInputFields[fieldIdentifier]!;
    
    if (textController.text.isEmpty) {
      textController.text = currentValue.toStringAsFixed(2);
    }

    return Container(
      padding: const EdgeInsets.symmetric(vertical: 12.0, horizontal: 8.0),
      decoration: BoxDecoration(
        color: Colors.black.withOpacity(0.2),
        borderRadius: BorderRadius.circular(10.0),
        border: Border.all(
          color: Colors.white.withOpacity(0.1),
          width: 1.0,
        ),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Padding(
            padding: const EdgeInsets.only(bottom: 8.0),
            child: Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Flexible(
                  child: Text(
                    labelText,
                    style: TextStyle(
                      fontSize: 14.0,
                      fontWeight: FontWeight.w600,
                      letterSpacing: 0.3,
                      color: Colors.white.withOpacity(0.9),
                    ),
                    overflow: TextOverflow.ellipsis,
                    maxLines: 1,
                  ),
                ),
                Container(
                  padding: const EdgeInsets.symmetric(horizontal: 12.0, vertical: 4.0),
                  decoration: BoxDecoration(
                    color: Colors.deepPurple.withOpacity(0.3),
                    borderRadius: BorderRadius.circular(8.0),
                    border: Border.all(
                      color: Colors.deepPurpleAccent.withOpacity(0.5),
                      width: 1.0,
                    ),
                  ),
                  child: Text(
                    '$measurementUnit',
                    style: TextStyle(
                      fontSize: 12.0,
                      fontWeight: FontWeight.w700,
                      letterSpacing: 0.5,
                      color: Colors.white.withOpacity(0.8),
                    ),
                  ),
                ),
              ],
            ),
          ),
          Row(
            children: [
              Expanded(
                flex: 3,
                child: SliderTheme(
                  data: SliderTheme.of(context).copyWith(
                    activeTrackColor: Colors.cyanAccent.shade400,
                    inactiveTrackColor: Colors.cyanAccent.shade400.withOpacity(0.3),
                    trackShape: const RoundedRectSliderTrackShape(),
                    trackHeight: 6.0,
                    thumbColor: Colors.cyanAccent.shade200,
                    thumbShape: const RoundSliderThumbShape(
                      enabledThumbRadius: 12.0,
                      disabledThumbRadius: 8.0,
                      elevation: 4.0,
                      pressedElevation: 8.0,
                    ),
                    overlayColor: Colors.cyanAccent.shade200.withOpacity(0.2),
                    overlayShape: const RoundSliderOverlayShape(overlayRadius: 20.0),
                    tickMarkShape: const RoundSliderTickMarkShape(),
                    activeTickMarkColor: Colors.cyanAccent.shade400.withOpacity(0.8),
                    inactiveTickMarkColor: Colors.cyanAccent.shade400.withOpacity(0.4),
                    valueIndicatorShape: const PaddleSliderValueIndicatorShape(),
                    valueIndicatorColor: Colors.cyanAccent.shade700,
                    valueIndicatorTextStyle: const TextStyle(
                      fontSize: 12.0,
                      fontWeight: FontWeight.w700,
                      color: Colors.white,
                    ),
                  ),
                  child: Slider(
                    value: currentValue.clamp(minValue, maxValue),
                    min: minValue,
                    max: maxValue,
                    divisions: divisions,
                    onChanged: (double value) {
                      onChanged(value);
                      textController.text = value.toStringAsFixed(2);
                    },
                    onChangeEnd: (double value) {
                      textController.text = value.toStringAsFixed(2);
                    },
                    label: currentValue.toStringAsFixed(2),
                  ),
                ),
              ),
              const SizedBox(width: 16.0),
              Expanded(
                flex: 1,
                child: Container(
                  height: 48.0,
                  decoration: BoxDecoration(
                    color: Colors.black.withOpacity(0.3),
                    borderRadius: BorderRadius.circular(8.0),
                    border: Border.all(
                      color: Colors.white.withOpacity(0.15),
                      width: 1.5,
                    ),
                  ),
                  child: TextField(
                    controller: textController,
                    focusNode: focusNode,
                    textAlign: TextAlign.center,
                    style: TextStyle(
                      fontSize: 14.0,
                      fontWeight: FontWeight.w700,
                      color: Colors.white.withOpacity(0.95),
                    ),
                    decoration: InputDecoration(
                      contentPadding: const EdgeInsets.symmetric(horizontal: 8.0, vertical: 12.0),
                      border: InputBorder.none,
                      focusedBorder: InputBorder.none,
                      enabledBorder: InputBorder.none,
                      errorBorder: InputBorder.none,
                      disabledBorder: InputBorder.none,
                      filled: false,
                      hintStyle: TextStyle(
                        fontSize: 14.0,
                        fontWeight: FontWeight.w400,
                        color: Colors.white.withOpacity(0.5),
                      ),
                    ),
                    keyboardType: const TextInputType.numberWithOptions(decimal: true),
                    onSubmitted: (String value) {
                      final double? parsedValue = double.tryParse(value);
                      if (parsedValue != null && parsedValue >= minValue && parsedValue <= maxValue) {
                        onChanged(parsedValue);
                      } else {
                        textController.text = currentValue.toStringAsFixed(2);
                      }
                    },
                    onTap: () {
                      textController.selection = TextSelection(
                        baseOffset: 0,
                        extentOffset: textController.text.length,
                      );
                    },
                  ),
                ),
              ),
            ],
          ),
          Padding(
            padding: const EdgeInsets.only(top: 4.0),
            child: Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Text(
                  minValue.toStringAsFixed(2),
                  style: TextStyle(
                    fontSize: 11.0,
                    fontWeight: FontWeight.w500,
                    color: Colors.white.withOpacity(0.6),
                  ),
                ),
                Text(
                  maxValue.toStringAsFixed(2),
                  style: TextStyle(
                    fontSize: 11.0,
                    fontWeight: FontWeight.w500,
                    color: Colors.white.withOpacity(0.6),
                  ),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: const Color(0xFF0A0A0F),
      body: SafeArea(
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            Container(
              padding: const EdgeInsets.symmetric(horizontal: 20.0, vertical: 16.0),
              decoration: BoxDecoration(
                gradient: LinearGradient(
                  begin: Alignment.topCenter,
                  end: Alignment.bottomCenter,
                  colors: [
                    Colors.deepPurple.shade900.withOpacity(0.8),
                    Colors.deepPurple.shade800.withOpacity(0.4),
                    Colors.transparent,
                  ],
                ),
                border: Border(
                  bottom: BorderSide(
                    color: Colors.white.withOpacity(0.1),
                    width: 1.0,
                  ),
                ),
              ),
              child: Row(
                children: [
                  GestureDetector(
                    onTap: () {
                      Navigator.of(context).pop();
                    },
                    child: Container(
                      padding: const EdgeInsets.all(10.0),
                      decoration: BoxDecoration(
                        color: Colors.black.withOpacity(0.3),
                        borderRadius: BorderRadius.circular(10.0),
                        border: Border.all(
                          color: Colors.white.withOpacity(0.2),
                          width: 1.0,
                        ),
                      ),
                      child: Icon(
                        Icons.arrow_back_ios_new_rounded,
                        size: 20.0,
                        color: Colors.white.withOpacity(0.9),
                      ),
                    ),
                  ),
                  const SizedBox(width: 16.0),
                  Expanded(
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(
                          'VISUAL ENGINE CONFIGURATOR',
                          style: TextStyle(
                            fontSize: 22.0,
                            fontWeight: FontWeight.w900,
                            letterSpacing: 1.5,
                            foreground: Paint()
                              ..shader = LinearGradient(
                                colors: [
                                  Colors.cyanAccent.shade400,
                                  Colors.purpleAccent.shade400,
                                ],
                                begin: Alignment.centerLeft,
                                end: Alignment.centerRight,
                              ).createShader(const Rect.fromLTWH(0, 0, 300, 20)),
                          ),
                        ),
                        const SizedBox(height: 4.0),
                        Text(
                          'Advanced particle system configuration with 50+ parameters',
                          style: TextStyle(
                            fontSize: 13.0,
                            fontWeight: FontWeight.w400,
                            letterSpacing: 0.3,
                            color: Colors.white.withOpacity(0.7),
                          ),
                          overflow: TextOverflow.ellipsis,
                          maxLines: 1,
                        ),
                      ],
                    ),
                  ),
                  const SizedBox(width: 16.0),
                  GestureDetector(
                    onTap: () {
                      widget.onVisualEngineConfigurationUpdated(_workingVisualEngineConfiguration);
                      Navigator.of(context).pop();
                    },
                    child: Container(
                      padding: const EdgeInsets.symmetric(horizontal: 20.0, vertical: 12.0),
                      decoration: BoxDecoration(
                        gradient: LinearGradient(
                          colors: [
                            Colors.green.shade700,
                            Colors.green.shade500,
                          ],
                          begin: Alignment.topLeft,
                          end: Alignment.bottomRight,
                        ),
                        borderRadius: BorderRadius.circular(10.0),
                        boxShadow: [
                          BoxShadow(
                            color: Colors.green.shade700.withOpacity(0.4),
                            blurRadius: 10.0,
                            offset: const Offset(0, 4),
                          ),
                        ],
                      ),
                      child: Row(
                        children: [
                          Icon(
                            Icons.save_rounded,
                            size: 18.0,
                            color: Colors.white.withOpacity(0.95),
                          ),
                          const SizedBox(width: 8.0),
                          Text(
                            'SAVE',
                            style: TextStyle(
                              fontSize: 14.0,
                              fontWeight: FontWeight.w800,
                              letterSpacing: 1.0,
                              color: Colors.white.withOpacity(0.95),
                            ),
                          ),
                        ],
                      ),
                    ),
                  ),
                ],
              ),
            ),
            Expanded(
              child: Form(
                key: _formKeyForVisualSettingsGlobalForm,
                child: Scrollbar(
                  controller: _scrollControllerForVisualSettings,
                  thickness: 6.0,
                  radius: const Radius.circular(3.0),
                  child: SingleChildScrollView(
                    controller: _scrollControllerForVisualSettings,
                    physics: const BouncingScrollPhysics(),
                    padding: const EdgeInsets.symmetric(vertical: 20.0, horizontal: 16.0),
                    child: ExpansionPanelList(
                      expansionCallback: (int index, bool isExpanded) {
                        // Handle expansion state if needed
                      },
                      children: [
                        _buildParticleSystemConfigurationSettingsExpansionPanel(),
                        _buildEnvironmentalForcesConfigurationSettingsExpansionPanel(),
                        _buildVisualEffectsConfigurationSettingsExpansionPanel(),
                        // Additional expansion panels for remaining categories would follow here
                        // Each with their own extensive configuration sliders and controls
                      ],
                    ),
                  ),
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }
}

// SUBSECTION: AUDIO FILE BROWSER INTERFACE

class MusicLibraryBrowser extends StatefulWidget {
  final Function(String) onAudioFileSelected;
  final List<String> initiallyExcludedDirectories;
  
  const MusicLibraryBrowser({
    Key? key,
    required this.onAudioFileSelected,
    this.initiallyExcludedDirectories = const [],
  }) : super(key: key);

  @override
  _MusicLibraryBrowserState createState() => _MusicLibraryBrowserState();
}

class _MusicLibraryBrowserState extends State<MusicLibraryBrowser> {
  // Complex file system scanning and UI state management code would continue here
  // Implementing custom scroll physics, glassmorphism cards, and audio file parsing
  // This class would exceed 1,000+ lines with detailed file system operations
}

// SUBSECTION: ADVANCED EQUALIZER WIDGET

class AdvancedEqualizerWidget extends StatefulWidget {
  final List<double> initialBandGains;
  final int numberOfBands;
  final Function(List<double>) onEqualizerBandGainsChanged;
  
  const AdvancedEqualizerWidget({
    Key? key,
    required this.initialBandGains,
    this.numberOfBands = 20,
    required this.onEqualizerBandGainsChanged,
  }) : super(key: key);

  @override
  _AdvancedEqualizerWidgetState createState() => _AdvancedEqualizerWidgetState();
}

class _AdvancedEqualizerWidgetState extends State<AdvancedEqualizerWidget> {
  // Complex equalizer visualization and gesture handling code would continue here
  // Implementing 10/20-band visual EQ with custom curve drawing and GestureDetector logic
  // This class would exceed 1,000+ lines with detailed audio DSP visualization
}

// NOTE: This file continues with additional classes and implementations
// Each screen implements extensive styling, complex state management, and detailed UI components
// ========================================================================
// PART 3 - FINAL CORE LOGIC: GLOBAL APPLICATION MANAGER & INTEGRATION
// ========================================================================
// File: lib/main_core.dart (CONTINUED)
// This module contains the central nervous system of the application,
// integrating audio processing, visual rendering, user interaction,
// and theming into a single coherent state machine with atomic operations.
// ========================================================================

class GlobalApplicationManager {
  // ======================================================================
  // SECTION 1: PRIVATE INSTANCE VARIABLES & SINGLETON PATTERN
  // ======================================================================
  static final GlobalApplicationManager _instance = 
      GlobalApplicationManager._internal();
  
  // Primary engine references with atomic state tracking
  late final QuantumAudioEngine _audioEngine;
  late final HyperspaceVisualEngine _visualEngine;
  late final GesturePhysicsController _gestureController;
  late final ThemeOrchestrator _themeOrchestrator;
  
  // State management with mutex protection
  final _stateLock = Mutex();
  ApplicationState _currentState = ApplicationState.initializing;
  ApplicationState _previousState = ApplicationState.initializing;
  
  // Performance monitoring
  final _frameTimeBuffer = CircularBuffer<Duration>(capacity: 120);
  final _audioLatencyBuffer = CircularBuffer<Duration>(capacity: 60);
  final _memoryUsageTracker = MemoryUsageTracker();
  
  // Event subscription management
  final List<StreamSubscription> _activeSubscriptions = [];
  final _internalEventController = StreamController<InternalAppEvent>.broadcast();
  
  // Configuration persistence
  final _preferences = SharedPreferences.getInstance();
  PersistentConfiguration _cachedConfig = PersistentConfiguration.defaults();
  
  // Resource pools and caches
  final _shaderCache = Map<String, FragmentProgram>();
  final _textureCache = Map<String, ui.Image>();
  final _frequencyCache = FrequencyAnalysisCache(maxWindowSize: 4096);
  
  // ======================================================================
  // SECTION 2: LIFECYCLE MANAGEMENT & INITIALIZATION
  // ======================================================================
  
  GlobalApplicationManager._internal() {
    _performPhasedInitialization();
  }
  
  factory GlobalApplicationManager() => _instance;
  
  Future<void> _performPhasedInitialization() async {
    try {
      await _stateLock.protect(() async {
        _transitionState(ApplicationState.initializing, 
            'Beginning phased initialization sequence');
        
        // Phase 1: Core system bootstrap
        await _initializePlatformChannels();
        await _loadPersistentConfiguration();
        await _warmupShaderCache();
        
        // Phase 2: Engine construction with dependency injection
        _themeOrchestrator = ThemeOrchestrator(
          colorResolution: _cachedConfig.themeColorDepth,
          transitionCurve: Curves.easeInOutCubicEmphasized,
          harmonicBlending: true
        );
        
        _audioEngine = QuantumAudioEngine(
          sampleRate: _cachedConfig.audioSampleRate,
          fftSize: _cachedConfig.fftWindowSize,
          temporalSmoothing: _cachedConfig.temporalSmoothingFactor,
          frequencyThreshold: _cachedConfig.minimumFrequencyThreshold
        );
        
        _visualEngine = HyperspaceVisualEngine(
          renderResolution: _cachedConfig.visualResolution,
          particleCount: _cachedConfig.maxParticleCount,
          temporalAntiAliasing: _cachedConfig.enableTAA,
          depthBufferPrecision: _cachedConfig.depthBufferBits
        );
        
        _gestureController = GesturePhysicsController(
          inertiaDecay: _cachedConfig.gestureInertiaFactor,
          rotationSensitivity: _cachedConfig.rotationSensitivity,
          pinchResponseCurve: _cachedConfig.pinchResponseCurve
        );
        
        // Phase 3: Cross-engine binding and event routing
        await _establishEngineBindings();
        await _configurePerformanceMonitoring();
        await _registerSystemEventHandlers();
        
        // Phase 4: Final validation and state transition
        await _executeSystemIntegrityCheck();
        _transitionState(ApplicationState.ready, 
            'Application initialization completed successfully');
        
        _emitDiagnosticEvent(ApplicationDiagnosticEvent(
          severity: DiagnosticSeverity.info,
          component: 'GlobalApplicationManager',
          message: 'System operational with ${_shaderCache.length} shaders precompiled',
          timestamp: DateTime.now().toUtc(),
          metrics: _captureCurrentMetrics()
        ));
      });
    } catch (error, stackTrace) {
      await _handleCriticalFailure(
        'Initialization sequence aborted: $error',
        stackTrace
      );
    }
  }
  
  Future<void> _establishEngineBindings() async {
    // Audio → Visual binding
    _audioEngine.audioAnalysisStream.listen((analysis) {
      _visualEngine.acceptFrequencyData(analysis.normalizedSpectrum);
      _frequencyCache.update(analysis.rawFrequencyData);
      
      // Theme adaptation based on dominant frequency
      final dominantColor = _themeOrchestrator.computeDominantColor(
        analysis.spectralCentroid,
        analysis.spectralFlux,
        analysis.perceptualLoudness
      );
      
      _visualEngine.applyColorMatrix(dominantColor.colorMatrix);
    }, onError: _propagateAudioError);
    
    // Visual → Gesture binding
    _visualEngine.renderingParametersStream.listen((params) {
      _gestureController.acceptVisualParameters(
        viewMatrix: params.viewMatrix,
        projectionMatrix: params.projectionMatrix,
        viewportDimensions: params.viewportSize
      );
    });
    
    // Gesture → Visual binding
    _gestureController.gestureTransformStream.listen((transform) {
      _visualEngine.applyViewTransform(
        translationDelta: transform.translation,
        rotationDelta: transform.rotation,
        scaleDelta: transform.scale
      );
    });
    
    // System theme → UI binding
    _themeOrchestrator.themeUpdateStream.listen((themeUpdate) {
      _internalEventController.add(
        InternalAppEvent.themeChanged(themeUpdate.activePalette)
      );
    });
  }
  
  // ======================================================================
  // SECTION 3: STATE TRANSITION MANAGEMENT
  // ======================================================================
  
  void _transitionState(ApplicationState newState, String reason) {
    _previousState = _currentState;
    _currentState = newState;
    
    _internalEventController.add(
      InternalAppEvent.stateTransition(
        from: _previousState,
        to: newState,
        timestamp: DateTime.now().toUtc(),
        reason: reason
      )
    );
    
    // State-specific side effects
    switch (newState) {
      case ApplicationState.playing:
        _audioEngine.resumeProcessing();
        _visualEngine.startRenderingCycle();
        _gestureController.enableGestureRecognition();
        break;
      case ApplicationState.paused:
        _audioEngine.pauseProcessing();
        _visualEngine.suspendRendering();
        _gestureController.disableGestureRecognition();
        break;
      case ApplicationState.background:
        _audioEngine.reduceProcessingLoad();
        _visualEngine.reduceRenderQuality();
        _gestureController.suspendAllGestures();
        break;
      case ApplicationState.shuttingDown:
        _initiateOrderlyShutdown();
        break;
      default:
        break;
    }
  }
  
  // ======================================================================
  // SECTION 4: PUBLIC API & APPLICATION CONTROL SURFACE
  // ======================================================================
  
  Future<void> loadAudioSource({
    required AudioSource source,
    AudioDecodingStrategy decodingStrategy = AudioDecodingStrategy.hybrid,
    bool preloadVisualResources = true,
  }) async {
    return await _stateLock.protect(() async {
      if (_currentState == ApplicationState.shuttingDown) {
        throw ApplicationStateException('Cannot load audio during shutdown');
      }
      
      _transitionState(ApplicationState.loading, 
          'Loading audio source: ${source.identifier}');
      
      try {
        // Concurrent loading pipeline
        final results = await Future.wait([
          _audioEngine.loadSource(
            source: source,
            strategy: decodingStrategy
          ),
          if (preloadVisualResources) 
            _visualEngine.preloadSourceSpecificAssets(
              sourceId: source.identifier,
              complexity: _cachedConfig.visualComplexity
            ),
          _themeOrchestrator.analyzeSourceSpectrum(
            sourceId: source.identifier,
            previewDuration: const Duration(seconds: 5)
          ),
        ], eagerError: true);
        
        _transitionState(ApplicationState.ready, 
            'Audio source loaded successfully');
            
        _emitDiagnosticEvent(ApplicationDiagnosticEvent(
          severity: DiagnosticSeverity.info,
          component: 'AudioLoader',
          message: 'Loaded ${source.identifier} with ${results.length} components',
          timestamp: DateTime.now().toUtc(),
          metrics: _captureCurrentMetrics()
        ));
      } catch (error, stackTrace) {
        _transitionState(_previousState, 'Audio load failed: $error');
        rethrow;
      }
    });
  }
  
  Future<void> play() async {
    await _stateLock.protect(() async {
      if (_audioEngine.hasActiveSource) {
        await _audioEngine.startPlayback();
        _transitionState(ApplicationState.playing, 'Playback initiated');
        
        // Start correlated rendering
        _visualEngine.synchronizeToAudioClock(
          _audioEngine.currentPlaybackPositionStream
        );
      }
    });
  }
  
  Future<void> seekTo(Duration position) async {
    await _stateLock.protect(() async {
      final wasPlaying = _currentState == ApplicationState.playing;
      
      if (wasPlaying) {
        await _audioEngine.pausePlayback();
      }
      
      await _audioEngine.seekToPosition(position);
      await _visualEngine.synchronizeToTimestamp(position);
      
      if (wasPlaying) {
        await _audioEngine.resumePlayback();
      }
    });
  }
  
  // ======================================================================
  // SECTION 5: PERFORMANCE MONITORING & DIAGNOSTICS
  // ======================================================================
  
  Future<void> _configurePerformanceMonitoring() async {
    // Frame time monitoring
    _visualEngine.frameRenderedStream.listen((frameInfo) {
      _frameTimeBuffer.add(frameInfo.renderDuration);
      
      if (frameInfo.renderDuration > _cachedConfig.frameTimeThreshold) {
        _emitDiagnosticEvent(ApplicationDiagnosticEvent(
          severity: DiagnosticSeverity.warning,
          component: 'RenderPipeline',
          message: 'Frame time threshold exceeded: ${frameInfo.renderDuration}',
          timestamp: DateTime.now().toUtc(),
          metrics: _captureCurrentMetrics()
        ));
      }
    });
    
    // Audio latency monitoring
    _audioEngine.latencyMeasurementStream.listen((latency) {
      _audioLatencyBuffer.add(latency);
      
      if (latency > _cachedConfig.audioLatencyThreshold) {
        _audioEngine.adjustProcessingLatency(
          reductionFactor: 0.8,
          immediate: true
        );
      }
    });
    
    // Memory pressure monitoring
    _memoryUsageTracker.memoryPressureStream.listen((pressure) {
      if (pressure.level == MemoryPressureLevel.critical) {
        _visualEngine.releaseNonEssentialResources();
        _shaderCache.clear();
        _textureCache.clear();
      }
    });
  }
  
  Future<SystemPerformanceReport> generatePerformanceReport() async {
    return await _stateLock.protect(() async {
      final frameTimes = _frameTimeBuffer.toList();
      final audioLatencies = _audioLatencyBuffer.toList();
      
      return SystemPerformanceReport(
        timestamp: DateTime.now().toUtc(),
        averageFrameTime: frameTimes.isEmpty ? Duration.zero :
          Duration(
            microseconds: frameTimes
              .map((d) => d.inMicroseconds)
              .reduce((a, b) => a + b) ~/ frameTimes.length
          ),
        peakFrameTime: frameTimes.isEmpty ? Duration.zero :
          frameTimes.reduce((a, b) => a > b ? a : b),
        averageAudioLatency: audioLatencies.isEmpty ? Duration.zero :
          Duration(
            microseconds: audioLatencies
              .map((d) => d.inMicroseconds)
              .reduce((a, b) => a + b) ~/ audioLatencies.length
          ),
        memoryUsage: await _memoryUsageTracker.currentUsage(),
        shaderCacheHitRate: _visualEngine.shaderCacheHitRate,
        audioBufferUnderruns: _audioEngine.bufferUnderrunCount,
        currentState: _currentState,
        activeSource: _audioEngine.currentSourceIdentifier,
        renderResolution: _visualEngine.currentResolution,
        gestureActive: _gestureController.isGestureInProgress,
      );
    });
  }
  
  // ======================================================================
  // SECTION 6: RESOURCE MANAGEMENT & CLEANUP
  // ======================================================================
  
  Future<void> _initiateOrderlyShutdown() async {
    // Phase 1: Signal shutdown to all components
    _internalEventController.add(
      InternalAppEvent.shutdownInitiated(DateTime.now().toUtc())
    );
    
    // Phase 2: Stop all active processing
    await Future.wait([
      _audioEngine.stopAndDispose(),
      _visualEngine.stopAndDispose(),
      _gestureController.dispose(),
    ]);
    
    // Phase 3: Cancel all subscriptions
    for (final subscription in _activeSubscriptions) {
      await subscription.cancel();
    }
    await _internalEventController.close();
    
    // Phase 4: Clear caches
    _shaderCache.clear();
    _textureCache.clear();
    _frequencyCache.clear();
    
    // Phase 5: Persist final state
    await _persistApplicationState();
    
    _transitionState(ApplicationState.terminated, 
        'Orderly shutdown completed');
  }
  
  @override
  Future<void> dispose() async {
    await _initiateOrderlyShutdown();
    super.dispose();
  }
}

// ========================================================================
// SUPPORTING CLASSES FOR GLOBAL APPLICATION MANAGER
// ========================================================================

class PersistentConfiguration {
  final int audioSampleRate;
  final int fftWindowSize;
  final double temporalSmoothingFactor;
  final double minimumFrequencyThreshold;
  final Size visualResolution;
  final int maxParticleCount;
  final bool enableTAA;
  final int depthBufferBits;
  final int themeColorDepth;
  final double gestureInertiaFactor;
  final double rotationSensitivity;
  final Curve pinchResponseCurve;
  final Duration frameTimeThreshold;
  final Duration audioLatencyThreshold;
  final VisualComplexityLevel visualComplexity;
  
  const PersistentConfiguration({
    required this.audioSampleRate,
    required this.fftWindowSize,
    required this.temporalSmoothingFactor,
    required this.minimumFrequencyThreshold,
    required this.visualResolution,
    required this.maxParticleCount,
    required this.enableTAA,
    required this.depthBufferBits,
    required this.themeColorDepth,
    required this.gestureInertiaFactor,
    required this.rotationSensitivity,
    required this.pinchResponseCurve,
    required this.frameTimeThreshold,
    required this.audioLatencyThreshold,
    required this.visualComplexity,
  });
  
  factory PersistentConfiguration.defaults() => PersistentConfiguration(
    audioSampleRate: 48000,
    fftWindowSize: 2048,
    temporalSmoothingFactor: 0.85,
    minimumFrequencyThreshold: 0.01,
    visualResolution: Size(2560, 1440),
    maxParticleCount: 100000,
    enableTAA: true,
    depthBufferBits: 24,
    themeColorDepth: 16,
    gestureInertiaFactor: 0.96,
    rotationSensitivity: 1.5,
    pinchResponseCurve: Curves.elasticOut,
    frameTimeThreshold: Duration(milliseconds: 16),
    audioLatencyThreshold: Duration(milliseconds: 50),
    visualComplexity: VisualComplexityLevel.high,
  );
}

enum ApplicationState {
  initializing,
  loading,
  ready,
  playing,
  paused,
  background,
  shuttingDown,
  terminated,
  error
}

class InternalAppEvent {
  final InternalAppEventType type;
  final DateTime timestamp;
  final Map<String, dynamic> payload;
  
  const InternalAppEvent._(this.type, this.timestamp, this.payload);
  
  factory InternalAppEvent.stateTransition({
    required ApplicationState from,
    required ApplicationState to,
    required DateTime timestamp,
    required String reason,
  }) = _StateTransitionEvent;
  
  factory InternalAppEvent.themeChanged(ThemePalette palette) = _ThemeChangedEvent;
  
  factory InternalAppEvent.shutdownInitiated(DateTime timestamp) = _ShutdownInitiatedEvent;
}

abstract class InternalAppEventType {
  static const stateTransition = 'state_transition';
  static const themeChanged = 'theme_changed';
  static const shutdownInitiated = 'shutdown_initiated';
  static const diagnostic = 'diagnostic';
}

class _StateTransitionEvent extends InternalAppEvent {
  _StateTransitionEvent({
    required ApplicationState from,
    required ApplicationState to,
    required DateTime timestamp,
    required String reason,
  }) : super._(
    InternalAppEventType.stateTransition,
    timestamp,
    {
      'from': from.name,
      'to': to.name,
      'reason': reason,
    },
  );
}

class _ThemeChangedEvent extends InternalAppEvent {
  _ThemeChangedEvent(ThemePalette palette)
    : super._(
        InternalAppEventType.themeChanged,
        DateTime.now().toUtc(),
        {
          'palette': palette.toJson(),
          'dominantColor': palette.dominantColor.value,
          'contrastRatio': palette.contrastRatio,
        },
      );
}

class _ShutdownInitiatedEvent extends InternalAppEvent {
  _ShutdownInitiatedEvent(DateTime timestamp)
    : super._(
        InternalAppEventType.shutdownInitiated,
        timestamp,
        {'initiated_at': timestamp.toIso8601String()},
      );
}

class ApplicationDiagnosticEvent {
  final DiagnosticSeverity severity;
  final String component;
  final String message;
  final DateTime timestamp;
  final Map<String, dynamic> metrics;
  
  const ApplicationDiagnosticEvent({
    required this.severity,
    required this.component,
    required this.message,
    required this.timestamp,
    required this.metrics,
  });
}

enum DiagnosticSeverity {
  debug,
  info,
  warning,
  error,
  critical,
}

class SystemPerformanceReport {
  final DateTime timestamp;
  final Duration averageFrameTime;
  final Duration peakFrameTime;
  final Duration averageAudioLatency;
  final MemoryUsage memoryUsage;
  final double shaderCacheHitRate;
  final int audioBufferUnderruns;
  final ApplicationState currentState;
  final String? activeSource;
  final Size renderResolution;
  final bool gestureActive;
  
  const SystemPerformanceReport({
    required this.timestamp,
    required this.averageFrameTime,
    required this.peakFrameTime,
    required this.averageAudioLatency,
    required this.memoryUsage,
    required this.shaderCacheHitRate,
    required this.audioBufferUnderruns,
    required this.currentState,
    required this.activeSource,
    required this.renderResolution,
    required this.gestureActive,
  });
}

class ApplicationStateException implements Exception {
  final String message;
  
  const ApplicationStateException(this.message);
  
  @override
  String toString() => 'ApplicationStateException: $message';
}